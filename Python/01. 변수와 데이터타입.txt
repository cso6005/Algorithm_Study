0.
(1)
bool(값) 다른 타입의 값을 논리형을 변환
빈문자열, 0, None => False

(2) 값, 변수의 타입 확인하는 함수 
type(age) 

---------------------------------
[ 문자열 관련 ]

(3) 문자열 글자수 세기 함수
print(name, len(name)) # 이순신 3

(4) s.split() 문자열 쪼개기
s = "사과|귤|배"

fruit_list = s.split('|')
a, b, c = s.split('|')

print(fruit_list)
print(b)

['사과', '귤', '배']
귤

(5) s.strip() 공백 없애는 함수
# 중간 공백을 없애는 함수는 없다. 로직으로 할 순 있지만
s2.lstrip() #왼쪽 공백을 없애는 것.
s2.rstrip() #오른쪽 공백 없애는 것.
s2.strip() #공백 없애기.

(6) s.replace() 특정 문자열을 다른 문자열로 대체
s3.replace('ab', '가') #ab 를 가 로 변경. 글자수 상관없이 그냥 대체 하는 것.

문자열을 인덱스로 뽑아 = 해서 대입하는 건 안됨.
즉 s3 를 아예 바꾸는 건 안 되지만 이 함수로 대체해서 다른 혹은 같은 이름의 변수에 새로 담는 것은 가능한 것

(7) s.count()  문자열 안에 특정 문자 or 문자열이 몇 개 인지?
s3.count('ab')

(8) 특정 문자열이 몇 번째에 있는지 알고 싶을 때
   s.index() 
s3.index('a') # 앞에서 제일 처음 나온 index를 반환
s3.index('ab')

   s.find()

두 함수는 동일한데 한 가지 다른 점은

s3.index('가') # 없는 것을 찾으면 error
s3.find('가') # 없는 문자열을 찾을 경우 -1을 반환

그래서 find 는 아래와 같이 쓰일 수 있다.

print( s3.find('가') == -1  )

이 뜻은 이 문자열에 "가"가 없다는 것을 bool로 반환받음.


-----------------------------------
1. 조건 연산자
var = "20대" if (age < 30) & (age >= 20) else "30대"

2. 논리 연산자 & | not ^
꼭 괄호 쳐주기 아니면 비트 연산으로 인식할 수도
result = (num > 5) & (num < 20)

3. 
a, b, c = 1, 2, 3 => tuple 대입법!
a = b = 0

4. 문자열 출력
# |로 구분하고 싶다면? sep('')
print("a", 20, "30", 3.333, sep = '|')

a|20|30|3.333

5.문자열 슬라이싱 헷갈릴 때
print(s[2:10]) # 2~ 9(10 - 1)
print(s[5:1:-1]) # 5 ~ 2(1+1) 까지 -1 씩 
print(s[-1:5:-1]) # -1 ~ 6(5+1) 까지 -1 씩 
print(s[-1:-5:-2]) # -1 ~ -4 까지 까지 -2 씩

# 슬라이싱 시, 끝 인덱스를 -1 또는 + 1 을 하는데 
# 시작에서 끝 숫자를 보았을 때 
# 시작 보다 끝이 뒤에 있는 인덱스 인 경우 끝에서 시작 인덱스를 향해 붙는다고 생각하고 즉 -1
# 시작 보다 끝이 앞에 있는 인덱스 인 경우 시작 인덱스로 향해 붙는다고 생각하고 즉 +1


6. formatting
(1)
print("이름: {} \n학교 : {}".format('최소영', '단국대학교'))
(2)
print("이름:%s, 나이:%d, 키:%.2f" %("최소영", 26, 157.5))
(3)
name, age, weight = "홍길동", 23, 72.7
print(f"이름: {name}, 나이: {age}, 몸무게: {weight}")